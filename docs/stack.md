### 1. Технологический Стек (The Golden Stack)

Этот выбор обусловлен правилом «минимальной когнитивной нагрузки»: каждая библиотека должна быть стандартом де-факто, чтобы агент знал её API наизусть.

#### **Backend (Сервер)**
*   **Runtime:** **Node.js 22 LTS**. Однопоточная модель идеально ложится на пошаговую стратегию. V8 прекрасно оптимизирует работу с массивами.
*   **Language:** **TypeScript 5.x (Strict Mode)**.
    *   *Критично:* `strict: true` в `tsconfig.json`. Типы — это «рельсы», по которым агент пишет код. Без них он начнет путать координаты `x,y` с индексами массива.
*   **Network:** **Socket.IO v4**.
    *   *Почему:* Реализация «комнат» (Rooms) из коробки решает сложнейшую задачу синхронизации Тумана Войны (см. ниже). Чистый WebSocket потребует от агента написания сложного менеджера подписок, где риск ошибки — 100%.
*   **Tooling:** **Nodemon** + **TS-Node** (для разработки), **PM2** (для продакшена).

#### **Frontend (Клиент)**
*   **Render:** **Native HTML5 Canvas 2D API**.
    *   *Почему:* Никаких PixiJS или Phaser. Агент часто путает версии их API (v5 vs v7). Context 2D (`ctx.fillRect`, `ctx.moveTo`) неизменен годами, агент владеет им в совершенстве.
*   **Build System:** **Vite**. Нулевой конфиг, мгновенная сборка TS.
*   **UI Overlay:** **Vanilla HTML/CSS**. Кнопки, лидерборд и чат верстаются обычными `<div>` поверх Canvas. React/Vue здесь избыточны и создадут лишний слой абстракции.

#### **Data & State**
*   **NoSQL Database:** Не требуется. Весь стейт живет в оперативной памяти (In-Memory).
*   **Persistence:** Периодический дамп стейта в JSON-файл (на случай перезагрузки сервера).

---

### 2. Архитектура Данных (Data-Oriented Design)

У нас 96,000 клеток (400x240). Если делать каждую клетку объектом `{x, y, owner, color}`, Node.js умрет от Garbage Collection (GC).

**Решение: Плоские типизированные массивы (Flat TypedArrays)**

В классе `World` мы храним карту как одномерные массивы байт. Это дает феноменальную скорость доступа и минимальное потребление памяти.

```typescript
class GameMap {
  readonly width = 400;
  readonly height = 240;
  // Индекс клетки = y * width + x

  // ID владельца (0-255). 0 = нейтрал.
  public owners: Uint8Array = new Uint8Array(400 * 240);

  // Таймер "защиты" клетки после покраски (кулдаун 15 тиков)
  // Используем Int8Array: если > 0, красить нельзя.
  public cooldowns: Int8Array = new Int8Array(400 * 240);
}
```
*Преимущество:* Весь мир занимает менее 200 КБ в памяти. Клонирование и обработка мгновенны.

---

### 3. Сетевая Архитектура и Туман Войны

Это самый сложный узел ТЗ. Как передавать данные игроку, не раскрывая "туман", и не перегружая сеть?

**Решение: Chunk-Based Room Subscription**

1.  **Виртуальная сетка чанков:** Мир разбит на чанки 16x16 клеток (всего 375 чанков).
2.  **Socket.IO Rooms:** Каждый чанк на сервере — это отдельная комната со строковым ID: `"chunk_12_8"` (x=12, y=8).
3.  **Подписка (Subscription Logic):**
    *   Сервер хранит `Set<ChunkID>` для каждого игрока — список чанков, где у него есть хотя бы 1 окрашенная клетка.
    *   При каждом тике (раз в 66мс) сервер проверяет: если игрок захватил клетку в новом чанке, сокет игрока автоматически подписывается (`socket.join`) на комнату этого чанка **И** 8 соседних.
    *   Если игрок потерял все клетки в чанке, он отписывается (с задержкой, чтобы не мигало).
4.  **Вещание (Broadcasting):**
    *   Когда юнит двигается внутри чанка `(12, 8)`, сервер отправляет пакет движения **только** в комнату `"chunk_12_8"`.
    *   *Результат:* Клиент физически не получает данные о юнитах на другом конце карты. Это идеальный анти-чит и оптимизация трафика, реализованная средствами библиотеки, а не ручным кодом.

---

### 4. Протокол Синхронизации (Сжатый JSON)

Агенту сложно работать с бинарными протоколами (Protobuf/Flatbuffers). Мы будем использовать **структурный JSON**, где ключи удалены, а порядок данных фиксирован.

**Пакет обновления (Snapshot):**
```json
[
  1234, // Tick ID (для интерполяции)
  [ // Units Update: [ID, Type, X, Y, Owner]
    [101, 2, 150.5, 200.1, 5],
    [102, 5, 152.0, 201.0, 5]
  ],
  [ // Map Changes (только дельты): [Index, NewOwner]
    [45021, 5],
    [45022, 5]
  ],
  [ // Events (выстрелы): [AttackerID, TargetID]
    [101, 805]
  ]
]
```
*   **Точность:** Координаты юнитов передаются с округлением до 2 знаков (150.55), чтобы не слать длинные хвосты float.
*   **Экономия:** Мы не шлем `{"id": 101}`, мы шлем `[101, ...]`. Это сокращает размер пакета на 40-60%.

---

### 5. Игровой Цикл (Game Loop)

#### Сервер (Authoritative)
Работает на фиксированной частоте 15 Гц (66.6 мс).
1.  **Обработка входящих пакетов:** Все команды (`Move`, `Build`) складываются в очередь.
2.  **Логика:**
    *   Применяем команды.
    *   Двигаем юнитов (Collision avoidance — простое отталкивание окружностей).
    *   Проверка захвата/покраски.
    *   Расчет экономики (раз в 15 тиков).
3.  **Сериализация:** Формируем дельты для каждого чанка.
4.  **Рассылка:** `io.to("chunk_X_Y").emit("u", chunkData)`.

#### Клиент (Interpolation)
Работает на частоте монитора (60/144 FPS).
1.  **Буфер состояний:** Клиент хранит массив последних 3-х полученных снепшотов.
2.  **Интерполяция:** Мы рендерим мир с задержкой в ~100мс (Interpolation Delay).
    *   Позиция юнита = `LinearInterpolation(PrevPos, NextPos, TimeFactor)`.
    *   Это обеспечивает идеально плавное движение при 30 FPS обновлениях, даже если пакеты приходят с джиттером.
3.  **Prediction (Предсказание):**
    *   Для движения юнитов prediction **не делаем** (слишком сложно для агента синхронизировать откат при коллизиях). Будет небольшая задержка управления, что допустимо для стратегии.
    *   Для **покраски** и UI (списание денег) делаем оптимистичное обновление (рисуем мгновенно, если сервер отверг — откатываем).

---

### 6. Структура Проекта (Файловая)

Четкая структура папок критична для агента, чтобы он понимал контекст импортов.

```text
/project-root
  package.json
  tsconfig.json (Shared config)
  /src
    /shared              <-- Общий код (DRY)
      constants.ts       <-- Размеры карты, баланс (JSON), типы юнитов
      types.ts           <-- Интерфейсы (IPacket, IUnitState)
      utils.ts           <-- Ф-ции: indexToX(i), xToChunk(x)
    /server
      main.ts            <-- Entry point, Express + Socket.IO init
      /core
        GameLoop.ts      <-- Цикл `setInterval`
        World.ts         <-- Uint8Array grid
        UnitManager.ts   <-- Логика движения и боя
        RoomManager.ts   <-- Управление подписками на чанки
    /client
      index.html
      vite.config.ts
      /assets            <-- Спрайты
      /src
        main.ts          <-- Инициализация
        /engine
          Renderer.ts    <-- Canvas context, слои (background, units)
          Interpolator.ts <-- Математика плавности
          Input.ts       <-- Обработка мыши/клавиатуры
        /ui
          HUD.ts         <-- Обновление DOM элементов
```

### 7. Итоговые рекомендации для промптинга

Когда будешь ставить задачу агенту, используй этот архитектурный план как "Конституцию".

1.  **Запрети классы для клеток:** "Use strictly `Uint8Array` for the map, never create a class for a Cell."
2.  **Настаивай на Socket.IO Rooms:** "Implement Fog of War purely via `socket.join('chunk_id')` mechanism."
3.  **Строгость типов:** "Every message sent over network must have a defined TypeScript interface in `shared/types.ts`."

Этот стек обеспечивает идеальный баланс между производительностью (TypedArrays, Chunks) и простотой реализации для AI (Canvas, Socket.IO, TypeScript). Это наиболее безопасный путь к рабочему MVP.